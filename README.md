# test how to use wasm-link
This captures what I learned about trying to use `wasm-link`
to combine multiple wasm files into a single file.

[Here](https://groups.google.com/forum/#!topic/emscripten-discuss/qLDhAIAQ5Zc) is
the discussion on [emscripten-discuss](https://groups.google.com/forum/#!topic/emscripten-discuss/qLDhAIAQ5Zc)
helped get this far.

One goal out of this is for [TurboScript](https://github.com/01alchemist/TurboScript)
to be able to create "libraries" for itself as well as link with `C/C++`
code from emcc.

# Prerequisites
Install [emcc](https://github.com/kripken/emscripten/wiki/WebAssembly) and
`wasm-link` is in [wabt](https://github.com/WebAssembly/wabt) globally.i
I compiled both from source.

# What I learned
Right now trying to use `wasm-link` with the output from emcc
does not work as can be seen trying to `make` in `lib/`
```
$ make
emcc -Oz addTwo.c --ignore-dynamic-linking -s WASM=1 -s SIDE_MODULE=1 -o addTwo.wasm
wasm2wast addTwo.wasm -o addTwo.wast
wasm-link addTwo.wasm inc.wasm -o addTwoInc.wasm
unsupported import module: envmake: *** [Makefile:11: addTwoInc.wasm] Error 1
```

I did determine `.wast` files could be created that can be
linked. I figured this out by looking in the wasm-link source
finding where the `unsupported import module` error was generated
in wabt/src/binary-reader-linker.cc:
```
Result BinaryReaderLinker::OnImport(uint32_t index,
                                    StringSlice module_name,
                                    StringSlice field_name) {
  if (!string_slice_eq_cstr(&module_name, WABT_LINK_MODULE_NAME)) {
    WABT_FATAL("unsupported import module: " PRIstringslice,
               WABT_PRINTF_STRING_SLICE_ARG(module_name));
  }
  return Result::Ok;
}

```
Which requires that the `module_name` be `WABT_LINK_MODULE_NAME` and
`WABT_LINK_MODULE_NAME` is `__extern`:
```
./wasm-link.h:#define WABT_LINK_MODULE_NAME "__extern"
```

I then looked at the `.wast` files generated by `emcc` and saw it was
using `env` for the module_name and hence the error:
```
$ cat inc.wast
(module
  (type (;0;) (func (param i32 i32) (result i32)))
  (type (;1;) (func (param i32) (result i32)))
  (type (;2;) (func))
  (import "env" "memoryBase" (global (;0;) i32))
  (import "env" "_addTwo" (func (;0;) (type 0)))
  (import "env" "memory" (memory (;0;) 256))
  (import "env" "table" (table (;0;) 0 anyfunc))
  (import "env" "tableBase" (global (;1;) i32))
  (func (;1;) (type 1) (param i32) (result i32)
    get_local 0
    i32.const 1
    call 0)
  (func (;2;) (type 2)
    nop)
  (func (;3;) (type 2)
    block  ;; label = @1
      get_global 0
      set_global 2
      get_global 2
      i32.const 5242880
      i32.add
      set_global 3
      call 2
    end)
  (global (;2;) (mut i32) (i32.const 0))
  (global (;3;) (mut i32) (i32.const 0))
  (export "_inc" (func 1))
  (export "__post_instantiate" (func 3))
  (export "runPostSets" (func 2)))
```

So I manually created my own versions of addTwo.wast and inc.wast which
are in `libwast/`, these are edited version of those generated by
`emcc` and are simple as I could make them:
are edited version of those generatesimpler:
```
wink@wink-envy:~/prgs/test-emcc/libwast
$ cat inc.wast
(module
  (type (;0;) (func (param i32 i32) (result i32)))
  (type (;1;) (func (param i32) (result i32)))
  (import "__extern" "_addTwo" (func (;0;) (type 0)))
  (func (;1;) (type 1) (param i32) (result i32)
    get_local 0
    i32.const 1
    call 0)
  (export "_inc" (func 1)))
wink@wink-envy:~/prgs/test-emcc/libwast
$ cat addTwo.wast
(module
  (type (;0;) (func (param i32 i32) (result i32)))
  (func (;0;) (type 0) (param i32 i32) (result i32)
    get_local 1
    get_local 0
    i32.add)
  (export "_addTwo" (func 0)))
```

Run `make clean && make` in `libwast/`:
```
wink@wink-envy:~/prgs/test-emcc/libwast
$ make clean && make
rm -f addTwoInc.wast addTwoInc.wasm addTwo.wasm inc.wasm
make: Circular addTwo.wast <- addTwo.wasm dependency dropped.
wast2wasm addTwo.wast -o addTwo.wasm
make: Circular inc.wast <- inc.wasm dependency dropped.
wast2wasm inc.wast -o inc.wasm
wasm-link addTwo.wasm inc.wasm -o addTwoInc.wasm
wasm2wast addTwoInc.wasm -o addTwoInc.wast
```

And the output `addTwoInc.wast` is created from the output of `wasm-link` is:
```
$ cat addTwoInc.wast
(module
  (type (;0;) (func (param i32 i32) (result i32)))
  (type (;1;) (func (param i32 i32) (result i32)))
  (type (;2;) (func (param i32) (result i32)))
  (func (;0;) (type 0) (param i32 i32) (result i32)
    get_local 1
    get_local 0
    i32.add)
  (func (;1;) (type 2) (param i32) (result i32)
    get_local 0
    i32.const 1
    call 0)
  (export "_addTwo" (func 0))
  (export "_inc" (func 1)))
```

It is interesting that wasm-link created two `type` entries for `addTwo`.
